### Version Control Systems

## Version Control Systems (VCS)

# System that keep track of change made to files

# Also known as SCM (Source Code Management)



### Distributed VCS

## Git, Mercurial

# The full repo resides locally

# Contains full history

# Server is almost not invloved

#	Commit often and offline

#	Work on the beach / train

# Can push and pull between repos

# Back ups -trivial and readily available	



### Git basics

## Only one .git directory at the top lebel (not sprinkled throughout directory structure like SVN)




### General workflow

# (empty) Create or (existing) clone repo

# Add changes to staging area

# Commit changes (from staging area to local repo)

# Push changes from local to remote reop



### Key concept

# Commit locally

# Push remotely



### Summary

# Git lets you snapshot changes to your code

# Promotes committing change often



### Git setup

## Setup properties globally

# $git config --global user.name "Super Hero"
# $git config --global user.email my@example.com



## Verify that an option has been set

# $git config <option>

# For example $git config user.name



## getting help on any Git command

# $git help <command>



### Initializing a Repo

## Where do I get a repo from ?

# 1. Create a new repo

#	$cd working_dir

#	$git init

#	(Possibly create a .gitignore file)

# 	$git add.
    (. Adds the entire current directory with subdirectories)

#	$git commit -m "remark on the commit, ex: Initial commit"



## 2. Clone an existing repo (for example from GitHub)

#	$git clone https://[giturl]

#	Many transfer protocol available

#		https:
#		git:



### git status

## git status

# Provude the current status of your repo



### git add

## git add <file/dir>

# Add untracked files to be tracked or 

# Add a modified tracked file to the staging area



### git diff


## git diff
# shows the difference between staging and working directory


## git diff --staged
# shows the changes between HEAD (last commit on current branch) and staging directory


## git diff HEAD
# shows the deltas between HEAD and working dir



### git commit


## git commit

## commits your changes to the repo
# Promps for a commit message in an editor

## Better, just use the -m(message) option
# $git commit -m "Your message is here"



### Skipping the staging area

## to skip the staging area - just use -a flag
# After initially adding the file!!!

## Either "-a", "-m", or "-am" will do the trick



### Going back in time

## Before committing

# $git checkout .
# Re-checkout all tracked files overwriting local changes



# $git checkout -- <file>
# Re-checkout just one specific file



## After committing
# $git revert HEAD
# Reverts the most recent commit



### Summary

# You have to add a file for tracking at least once before it can make it into the repo

# Can easily go back in time to a snapshot



### Remote Repos and Github

## $git remote add alias [remote_url]
# Link remote repo with your local repo


## origin - default alias for a cloned repo

## $git push alias branch_name
# Push changes to your branch or master out



### Github

## Web-based hosting service for software projects that use git.


## Why use github ?
# Community-oriented
# Social networking functionality
#	Feeds
#	Followes
#	Watching projects

# Imteresting social networking graphs
# Wiki, Issue tracking




// Push local repository into server side git
$ git push -u origin master



### Ruby: High Level Overview

## Dynamic

## Object-oriented
# object-possessed, almost everything is an object

## Elegant, expressive and declarative
# Terse at times, but extremely readable

## Influenced by Perl, Smalltalk, Eiffel, and LISP
# Designed to make programmers happy



### Ruby basics

## 2 space indentation for each nested level is encouraged
# Not required mandatory (unlike Python)



## "#" is used for comments
# Use comments in moderation - the code itself should tell the story



## Everything is evaluated



### Printing to Console

## puts - standard Ruby method to print string to console (as in put string)

# Add a new line after the printed string
# Similar to System.out.println() in Java
# Used for most of the examples
# "puts obj" is equivalent to "puts obj.to_s"

## p - prints out internal representation of an object

# debbuger-style output
# "p obj" is equivalent to "put obj.inspect"

p "Got ot"
# => Got it



### Naming conventions

## Variables
# Lowercase or snake_case if multiple words

## Constants
# Either ALL_CAPS or FirstCap

## Classes (and Modules)
# CamelCase



### Drop the semicolons

## Leave semicolons off at the end of the file

## Can cram several statements in with a semicolon in between
# usually highy discouraged

Example:
a = 3 # semicolons not needed
a = 5; b = 7 # sometimes used, but not couraged



### IRB - Interactive Ruby

## Console-based interactive Ruby interpreter
# REPL ( Read Evaluate Print Loop )

## Comes with a Ruby installation


## Lets you experiment with quick feedback



### Summary of Ruby basics

# Ruby is extremely expressive

# Everything is evaluated



### Flow of Control

## basic flow control unit

# if/elsif/else
# case 
# until/unless ?
# while/for 

## What True and what is False ?

## What in the world is === ?



### Flow of control

# if/unless/elsif/else

# No parentheses or curly braces

# Use end to close flow control block



### Modifier form 

# if, unless, while, until - on the same line as the statement



### Ture/False

# true/false judgement in Ruby

# "false" and "nil object" are false

# Everything else is True

# Example:

puts "0 is true" if 0                           # 0 is true
puts "string false is true" if "false"          # "false" is true
puts "boolean false is false" if false          # boolean false is false
puts "empty string is true" if ""               # empty string is true
puts "string nil is true" if "nil"              # string nil is true
puts "absence of object nil is false" if nil    # absence of object nil is false



### Triple Equal

# Triple Equal ===

# "Equal" in its own way
# Sometimes it's not about being exactly equal, but judge the property of belonging

# Example:



if /sera/ === "coursera"
    puts " regular expression /sera/ triple equlas 'coursera' "
end



if "Hello" === 'Hello'
    puts "\"Hello\" triple equals 'Hello'"
end


if Integer === 66
    puts "66 is an Integer"
end


if String === 'Hello'
    puts "'Hello' is a string"
end


if (1..100) === 99
    puts "99 is in the range (1..100)"
end


if [1, 2, 3] === 1
    nil
else
    puts "We can not use triple equal to judge membership for a number over a list"
end



### Case expressions

## Two flavors

# 1. Similar to a series of "if" statements

# 2. Specify a target next to "case" and each when "clause" is compared to target.



## '===' is called the case equality operator because it is used in precisely this case.

## No fall-through logic

# Example:



age = 20

case # 1st type of case syntax
    when age >= 18
        puts "You can drive a car"
    else
        puts "Younger than minimim dirving age."
end



name = 'Fisher'

case name # 2nd type of case syntax
    when /fish/i then puts "This name include 'fish' inside."
    when 'Smith' then puts "Your name is Smith"
end



### for Loop

## Hardly used

## each / times preferred


## Comparison:

# Python's range operator gives tail-exclusive interval 
# Ruby's range operator x..y gives tail-inclusive interval

# Example:


# 0..10 is an instance of range data type in Ruby
for i in 0..10
    puts i 
end



### Summary of flow control

# Lots of options for flow control

# Modifier form is an interesting way to be ery expressive

# Non-nil and non-false values are always logic True in Ruby



### Functions / Methods

# Definitions

# How do we call them?

# What and how do they return?

# Default argument

## How to make methods more expressive

## What is "splat"



### Functions and Methods

## Technically, 
a function is defined outside of a class and 
a method is defined inside a class

## In Ruby, every function/method has at least one class it belongs to
# Not always written inside a class



### Methods

# Parentheses are optional both when defining and calling a method

# Recommend to use for clarity



### function return

# No need to declare type of parameters

# Can return whatever you want 

# "return" keyword is optional in Ruby (last execution line of a function)

# Example:

def add_1( x, y)
    (x + y)
end



def add_2( x, y)
    return (x + y)
end



def divide( x, y)
    return "Division by zero is not allowed" if 0 == y 
    return (x/y)
end

puts add_1( 3, 5 )
puts add_2( 3, 5 )

puts divide( 12, 4)
puts divide( 12, 0)



### Expressive Method Names

## Method name can end with

# '?' - Predicate methods

# '!' - Dangerous side-effect

# Example:

def can_divide_by?( number )
    return false if number.zero?
    return true
end

puts can_divide_by? 6

puts can_divide_by? 0



### Default arguments

## Methods can have default arguments

# If a value is passed in - use that passed in value

# Otherwise - use the default value provided

# Example:


def factorial( n )
    return n == 0? 1 : ( n * factorial( n-1 ) )
end

def factorial_default_arg( n = 5 )
    return n == 0? 1 : ( n * factorial_default_arg(n-1) )
end



puts factorial 5
puts factorial(5)
puts factorial_default_arg(5)
puts factorial_default_arg
puts factorial_default_arg(3)



### Splat

# "*" prefix defines a variable length parameter 

# can even apply to middle parameter, not just the last

# Example:


def find_max_from_variable_length_argument(first, *aSeriesOfNumber, last)
    # variable length argument passed in, and become a array of numbers
    return aSeriesOfNumber.max 
end

puts find_max_from_variable_length_argument("Head", 1, 88, 100, 5, "Tail")



### Summary of function

# There is no need to declare parameter type passed in or returned (dynamic)

# "return" is optional, by Ruby definition, the last executable line is automatically "returned"

# We can construct methods with variable length of parameter and pass them into function

# In addition, we can set default argument value in advance.



### Blocks

# How they are used?

# How to incorporate them into our own method?



### Blocks

## Chunks of code

# Enclosed between either curly braces {} or the keywords do and end

# Passes to methods as last "parameter"

## Convention

# Use {} when block content is a single line

# Use "do" and "end" when block content spans multiple lines

## Ofter used as iterators



### Coding with Blocks

## Two ways to configure a block in our own method

## Implicit

# Use "block_given?" to see if block was passed in

# Use "yield" to call the block_given


## Explicit

# Use "&" in front of the last "parameter"

# Use "call" method to call the block



### Summary

## Blocks are just code that you can pass into methods.

## When incorporating into your own methods:
# Either use blocks implicitly
# Or call them explicitly



### file

# Reading and writing to files

# exceptions

# reading values from environment variable



### Summary of file and exceptions

# File automatically closed at the end of the block

# Either use exception handling or check for existence of the file before accessing



### Outline of String

# Different kinds of strings supported by Ruby

# Many methods supported by the String API

# Symbols



### String

## Single-quote literal strings are very literal

# Allow escaping of ' with \

# Show (almost) everything else as is



## Double-quoted strings

# Interpret special characers like \n as newline and \t as tab width

# Allow string interpolation

# Support placehoder for dynamic string output on run-time



### More strings

## String methods ending with ! modify the existing string
# Most other just return a new string

## Can also use %Q{long multiline string}
# Same behavior as double-quoted string



### Overview of Symbols

## :foo- highly optimized strings

## Constant names that you don't have to predeclare
# "Stands for something" string type



### Symnols

## Guaranteed to be unique and immutable
                    ^^^^^^     ^^^^^^^^^

## Can be coverted to a String with to_s
## Similarly, it can be converted to Symbol with to_sym

## Symbol can be a representation of a method name

## Symbols and Strings are similar - 
## We must determine which makes more sense to use



### Summary of Symbols

# Interpolation lets you finish your thought 

# Strings have a lot of really useful API